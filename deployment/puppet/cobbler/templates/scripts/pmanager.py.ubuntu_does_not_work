#!/usr/bin/env python

import json

class PManager(object):
    def __init__(self, data):
        if isinstance(data, (str, unicode)):
            self.data = json.loads(data)
        else:
            self.data = data

        self.factor = 1
        self.unit = "MiB"
        self.targetmount = "/target"

        self._pre = []
        self._kick = []
        self._post = []

        self._pcount = {}
        self._pend = {}
        self._rcount = -1
        self._pvcount = 0

    def pcount(self, disk_id, increment=0):
        self._pcount[disk_id] = self._pcount.get(disk_id, 0) + increment
        return self._pcount.get(disk_id, 0)

    def psize(self, disk_id, increment=0):
        self._pend[disk_id] = self._pend.get(disk_id, 0) + increment
        return self._pend.get(disk_id, 0)

    def rcount(self, increment=0):
        self._rcount += increment
        return self._rcount

    def pvcount(self, increment=0):
        self._pvcount += increment
        return self._pvcount

    def pre(self, command=None):
        if command:
            if isinstance(command, list):
                return self._pre.extend(command)
            else:
                return self._pre.append(command)
        return self._pre

    def post(self, command=None):
        if command:
            if isinstance(command, list):
                return self._post.extend(command)
            else:
                return self._post.append(command)
        return self._post

    def _parttype(self, n):
        return "primary"

    def _getsize(self, vol):
        return vol["size"]

    def _gettabfstype(self, vol):
        if vol["mount"] == "/":
            return "ext4"
        elif vol["mount"] == "/boot":
            return "ext3"
        elif vol["mount"] == "swap":
            return "swap"
        return "xfs"

    def boot(self):
        self.plains(volume_filter=lambda x: x["mount"] == "/boot")
        self.raids(volume_filter=lambda x: x["mount"] == "/boot")

    def notboot(self):
        self.plains(volume_filter=lambda x: x["mount"] != "/boot")
        self.raids(volume_filter=lambda x: x["mount"] != "/boot")

    def clean(self, disk):
        self.pre("hdparm -z /dev/{0}".format(disk["id"]))
        self.pre("test -e /dev/{0} && dd if=/dev/zero "
                        "of=/dev/{0} bs=1M count=1024".format(disk["id"]))
        self.pre("sleep 5")
        self.pre("hdparm -z /dev/{0}".format(disk["id"]))

    def gpt(self, disk):
        self.pre("parted -s /dev/{0} mklabel gpt".format(disk["id"]))

    def bootable(self, disk):
        """Create and mark Bios Boot partition to which grub will
        embed its code later, useable for legacy boot.
        May be way smaller, but be aware that the parted may
        shrink 1M partition to zero at some disks and versions."""
        self.pre("parted -a none -s /dev/{0} "
                 "unit {3} mkpart primary {1} {2}".format(
                     disk["id"],
                     self.psize(disk["id"]),
                     self.psize(disk["id"], 24 * self.factor),
                     self.unit
            )
        )
        self.pre("parted -s /dev/{0} set {1} bios_grub on".format(
                     disk["id"],
                     self.pcount(disk["id"], 1)
            )
        )

        """Create partition for the EFI boot, minimum
        size is 100M, recommended is 200M, with fat32 and
        future mountpoint in the /boot/efi. There is also
        '/usr/sbin/parted -s /dev/sda set 2 boot on'
        which is strictly needed for EFI boot."""
        self.pre("parted -a none -s /dev/{0} "
                 "unit {3} mkpart primary fat32 {1} {2}".format(
                     disk["id"],
                     self.psize(disk["id"]),
                     self.psize(disk["id"], 200 * self.factor),
                     self.unit
            )
        )
        self.pre("parted -s /dev/{0} set {1} boot on".format(
                     disk["id"],
                     self.pcount(disk["id"], 1)
            )
        )

    def _plain_format(self, fs_type, disk_id, part_num, mount, size):
        commands = []
        if fs_type != "swap":
            commands.append("mkfs.{0} $(basename `readlink -f /dev/{1}`)"
                            "{2}".format(fs_type, disk_id, part_num))
        tabmount = mount if mount != "swap" else "none"
        if tabmount != "none":
            commands.append("mkdir -p {0}{1}".format(
                self.targetmount, mount))
            # commands.append("mount /dev/md{0} {1}{2}"
            #                 "".format(raid_num, self.targetmount, mount))
        commands.append("echo 'UUID=$(blkid -s UUID -o value "
                        "$(basename `readlink -f /dev/{0}`){1}) "
                        "{2} {3} defaults 0 0'"
                        " >> {4}/etc/fstab".format(
                            disk_id, part_num, tabmount,
                            fs_type, self.targetmount))
        return commands

    def plains(self, volume_filter=None):
        if not volume_filter:
            volume_filter = lambda x: True
        for disk in [d for d in self.data if d["type"] == "disk"]:
            for part in filter(lambda p: p["type"] == "partition" and
                               volume_filter(p), disk["volumes"]):
                if part["size"] <= 0:
                    continue
                pcount = self.pcount(disk["id"], 1)
                self.pre("parted -a none -s /dev/{0} "
                         "unit {4} mkpart {1} {2} {3}".format(
                             disk["id"],
                             self._parttype(pcount),
                             self.psize(disk["id"]),
                             self.psize(disk["id"], part["size"] * self.factor),
                             self.unit))

                self.pre(self._plain_format(self._gettabfstype(part),
                                            disk["id"], pcount, part["mount"],
                                            self._getsize(part)))

    def _raid_format(self, devices, fs_type, mount):
        """
        devices must be string like "/dev/sda1 /dev/sdb2"
        """
        commands = []
        raid_num = self.rcount(1)
        commands.append("sleep 5")
        [commands.append("hdparm -z /dev/{0}".format(d["id"]))
         for d in self.data if d["type"] == "disk"]
        commands.append("mdadm --create /dev/md{0} --run --level=1 "
                 "--raid-devices={1} --metadata=1.0 {2}"
                 "".format(raid_num, len(devices), " ".join(devices)))
        if fs_type != "swap":
            commands.append("mkfs.{0} /dev/md{1}".format(fs_type, raid_num))
        tabmount = mount if mount != "swap" else "none"
        if tabmount != "none":
            commands.append("mkdir -p {0}{1}".format(
                self.targetmount, mount))
            # commands.append("mount /dev/md{0} {1}{2}"
            #                 "".format(raid_num, self.targetmount, mount))
        commands.append("echo 'UUID=$(blkid -s UUID -o value /dev/md{0}) "
                        "{1} {2} defaults 0 0'"
                        " >> {3}/etc/fstab".format(raid_num, tabmount,
                                                   fs_type, self.targetmount))
        return commands

    def raids(self, volume_filter=None):
        if not volume_filter:
            volume_filter = lambda x: True
        devices_dict = {}
        for disk in [d for d in self.data if d["type"] == "disk"]:
            for raid in filter(lambda p: p["type"] == "raid" and
                               volume_filter(p), disk["volumes"]):
                if raid["size"] <= 0:
                    continue
                pcount = self.pcount(disk["id"], 1)
                begin_size = self.psize(disk["id"])
                end_size = self.psize(disk["id"], raid["size"] * self.factor)
                self.pre("parted -a none -s /dev/{0} "
                         "unit {4} mkpart {1} {2} {3}".format(
                             disk["id"], self._parttype(pcount),
                             begin_size, end_size, self.unit))

                if not devices_dict.get(raid["mount"]):
                    devices_dict[raid["mount"]] = []
                devices_dict[raid["mount"]].append(
                    "$(readlink -f /dev/{0}){1}".format(disk["id"], pcount))

        for mount, devs in devices_dict.iteritems():
            fs_type = self._gettabfstype({"mount": mount})
            self.pre(self._raid_format(devs, fs_type, mount))

    def _pv_format(self, devices, vgname):
        """
        devices must be string like "/dev/sda1 /dev/sdb2"
        """
        commands = []
        raid_num = self.rcount(1)
        commands.append("sleep 5")
        [commands.append("hdparm -z /dev/{0}".format(d["id"]))
         for d in self.data if d["type"] == "disk"]
        for dev in devices:
            commands.append("ls -l /dev/sd*")
            commands.append("dd if=/dev/zero of={0} bs=1M count=32".format(dev))
            commands.append("pvscan")
            commands.append("pvremove -f {0}".format(dev))
            commands.append("pvcreate --dataalignment 1024k {0}".format(dev))
        commands.append("vgscan")
        commands.append("vgremove -f {0}".format(vgname))
        commands.append("vgcreate -s 32m {0} {1}"
                 "".format(vgname, " ".join(devices)))
        return commands

    def pvs(self):
        devices_dict = {}
        for disk in [d for d in self.data if d["type"] == "disk"]:
            for pv in [p for p in disk["volumes"] if p["type"] == "pv"]:
                if pv["size"] <= 0:
                    continue
                pcount = self.pcount(disk["id"], 1)
                begin_size = self.psize(disk["id"])
                end_size = self.psize(disk["id"], pv["size"] * self.factor)
                self.pre("parted -a none -s /dev/{0} "
                         "unit {4} mkpart {1} {2} {3}".format(
                             disk["id"], self._parttype(pcount),
                             begin_size, end_size, self.unit))
                if not devices_dict.get(pv["vg"]):
                    devices_dict[pv["vg"]] = []
                devices_dict[pv["vg"]].append("$(readlink -f /dev/{0}){1}"
                                              "".format(disk["id"], pcount))
        for vg, devs in devices_dict.iteritems():
            self.pre(self._pv_format(devs, vg))

    def _lv_format(self, vgname, lvname, fs_type, mount, size):
        commands = []
        commands.append("lvcreate -L {0}m -n {1} {2}"
                        "".format(size, lvname, vgname))

        tabmount = mount if mount != "swap" else "none"
        if tabmount != "none":
            commands.append("mkdir -p {0}{1}"
                            "".format(self.targetmount, mount))
        """
        The name of the device. An LVM device is
        expressed as the volume group name and the logical
        volume name separated by a hyphen. A hyphen in
        the original name is translated to two hyphens.
        """
        commands.append("echo '/dev/mapper/{0}-{1} {2} {3} defaults 0 0'"
                        " >> {4}/etc/fstab".format(vgname.replace("-", "--"),
                                                   lvname.replace("-", "--"),
                                                   tabmount, fs_type,
                                                   self.targetmount))
        return commands

    def lvs(self):
        for vg in [g for g in self.data if g["type"] == "vg"]:
            for lv in vg["volumes"]:
                if lv["size"] <= 0:
                    continue
                self.pre(self._lv_format(vg["id"], lv["name"],
                                         self._gettabfstype(lv),
                                         lv["mount"], self._getsize(lv)))


class KickstartPManager(PManager):
    def __init__(self, data):
        super(KickstartPManager, self).__init__(data)
        self.targetmount = "/mnt/sysimage"
        self._r2count = 0

    def r2count(self, increment=0):
        self._r2count += increment
        return self._r2count

    def kick(self, command=None):
        if command:
            return self._kick.append(command)
        return self._kick

    def _getkickfstype(self, fs_type):
        if fs_type == "swap":
            return ""
        return "--fstype=%s" % fs_type

    def _getsize(self, vol):
        """Anaconda has hard coded limitation in 16TB
        for ext3/4 and xfs filesystems (the only filesystems
        we are supposed to use). Besides there is no stable
        64-bit ext4 implementation at the moment, so the
        limitation in 16TB for ext4 is not only
        anaconda limitation."""

        """Root partition can not be located on xfs file system
        therefore we check if root filesystem is larger
        than 16TB and set it size into 16TB if it is larger.
        It is necessary to note that to format 16TB
        volume on ext4 it is needed about 1G memory."""
        if vol["size"] > 16777216 and vol["mount"] == "/":
            return 16777216
        return super(KickstartPManager, self)._getsize(vol)

    def _plain_format(self, fs_type, disk_id, part_num, mount, size):
        """
        Anaconda is able to create partitions which are smaller than 16T
        """
        if size > 0 and size <= 16777216:
            kickfstype = "--fstype=%s" % fs_type
            if fs_type == "swap":
                 kickfstype = ""
            self.kick("partition {0} --onpart=$(readlink -f /dev/{1}){2} "
                      "{3}".format(mount, disk_id, part_num, kickfstype))
        else:
            self.post(super(KickstartPManager, self)._format(
                fs_type, disk_id, part_num, mount))

    def _raid_format(self, devices, fs_type, mount):
        raid_num = self.rcount(1)
        rnames = []
        for dev in devices:
            rname = "raid.{0:03d}".format(self.r2count(1))
            rnames.append(rname)
            self.kick("partition {0} --onpart={1}".format(rname, dev))
        self.kick("raid {0} --device=md{1} --fstype={2} "
                  "--level=RAID1 {3}".format(mount, raid_num,
                                             fs_type, " ".join(rnames)))

    def _pv_format(self, devices, vgname):
        pvnames = []
        for dev in devices:
            pvname = "pv.{0:03d}".format(self.pvcount(1))
            pvnames.append(pvname)
            self.kick("partition {0} --onpart={1}".format(pvname, dev))
        self.kick("volgroup {0} {1}".format(vgname, " ".join(pvnames)))

    def _lv_format(self, vgname, lvname, fs_type, mount, size):
        """
        Anaconda is able to create partitions which are smaller than 16T
        """
        if size > 0 and size <= 16777216:
            kickfstype = "--fstype=%s" % fs_type
            if fs_type == "swap":
                kickfstype = ""

            self.kick("logvol {0} --vgname={1} --size={2} "
                      "--name={3} {4}".format(mount, vgname,
                                              size, lvname, kickfstype))
        else:
            self.post(super(KickstartPManager, self)._lv_format(
                vgname, lvname, fs_type, mount, size))

    def bootloader(self):
        devs = []
        for disk in [d for d in self.data if d["type"] == "disk"]:
            devs.append("$(basename `readlink -f /dev/{0}`)"
                        "".format(disk["id"]))
        if devs:
            self.kick("bootloader --location=mbr --driveorder={0} "
                      "--append=' biosdevname=0 "
                      "crashkernel=none'".format(",".join(devs)))

    def expose(self,
               kickfile="/tmp/partition.ks",
               postfile="/tmp/post_partition.ks"
        ):
        result = ""
        for pre in self.pre():
            result += "{0}\n".format(pre)

        result += "echo > {0}\n".format(kickfile)
        for kick in self.kick():
            result += "echo \"{0}\" >> {1}\n".format(kick, kickfile)

        result += "echo > {0}\n".format(postfile)
        for post in self.post():
            result += "echo \"{0}\" >> {1}\n".format(post, postfile)
        return result

    def eval(self):
        for disk in [d for d in self.data if d["type"] == "disk"]:
            self.clean(disk)
            self.gpt(disk)
            self.bootable(disk)
        self.boot()
        self.notboot()
        self.pvs()
        self.lvs()
        self.bootloader()
        self.pre("sleep 10")
        for disk in [d for d in self.data if d["type"] == "disk"]:
            self.pre("hdparm -z /dev/{0}".format(disk["id"]))


class PreseedPManager(PManager):
    def expose(self):
        result = ""
        for pre in self.pre():
            result += "echo '{0}' >>/tmp/partman-fuel.log 2>&1;\\\n".format(pre)
            result += "{0} >>/tmp/partman-fuel.log 2>&1;\\\n".format(pre)
        result += "true\n"
        return result

    def eval(self):
        for disk in [d for d in self.data if d["type"] == "disk"]:
            self.clean(disk)
            self.gpt(disk)
            self.bootable(disk)
        self.boot()
        self.notboot()
        self.pvs()
        self.lvs()
        #self.bootloader()
        self.pre("sleep 10")
        for disk in [d for d in self.data if d["type"] == "disk"]:
            self.pre("hdparm -z /dev/{0}".format(disk["id"]))

def kpm(data):
    pmanager = KickstartPManager(data)
    pmanager.eval()
    return pmanager.expose()

def ppm(data):
    pmanager = PreseedPManager(data)
    pmanager.eval()
    return pmanager.expose()



j = """
[
    {
        "name": "sda",
        "free_space": 101772,
        "volumes": [
            {
                "type": "boot",
                "size": 300
            },
            {
                "mount": "/boot",
                "type": "raid",
                "size": 200
            },
            {
                "type": "lvm_meta_pool",
                "size": 0
            },
            {
                "size": 12352,
                "type": "pv",
                "lvm_meta_size": 64,
                "vg": "os"
            },
            {
                "size": 89548,
                "type": "pv",
                "lvm_meta_size": 64,
                "vg": "image"
            }
        ],
        "type": "disk",
        "id": "disk/by-path/pci-0000:00:06.0-scsi-0:0:0:0",
        "size": 102400
    },
    {
        "name": "sdb",
        "free_space": 101772,
        "volumes": [
            {
                "type": "boot",
                "size": 300
            },
            {
                "mount": "/boot",
                "type": "raid",
                "size": 200
            },
            {
                "type": "lvm_meta_pool",
                "size": 64
            },
            {
                "size": 0,
                "type": "pv",
                "lvm_meta_size": 0,
                "vg": "os"
            },
            {
                "size": 101836,
                "type": "pv",
                "lvm_meta_size": 64,
                "vg": "image"
            }
        ],
        "type": "disk",
        "id": "disk/by-path/pci-0000:00:06.0-scsi-0:0:1:0",
        "size": 102400
    },
    {
        "min_size": 12288,
        "type": "vg",
        "id": "os",
        "volumes": [
            {
                "mount": "/",
                "type": "lv",
                "name": "root",
                "size": 10240
            },
            {
                "mount": "swap",
                "type": "lv",
                "name": "swap",
                "size": 2048
            }
        ],
        "label": "Base System"
    },
    {
        "min_size": 5120,
        "type": "vg",
        "id": "image",
        "volumes": [
            {
                "mount": "/var/lib/glance",
                "type": "lv",
                "name": "glance",
                "size": 191256
            }
        ],
        "label": "Image Storage"
    }
]
"""



